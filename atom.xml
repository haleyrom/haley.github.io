<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haley</title>
  
  <subtitle>Blog,博客,分享,开源,心得</subtitle>
  <link href="http://www.haleyl.com/atom.xml" rel="self"/>
  
  <link href="http://www.haleyl.com/"/>
  <updated>2021-03-31T09:08:59.413Z</updated>
  <id>http://www.haleyl.com/</id>
  
  <author>
    <name>子恒|Haley</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nodejs 14 特性 实验性异步本地存储API</title>
    <link href="http://www.haleyl.com/2020/12/01/node/node14_storage/"/>
    <id>http://www.haleyl.com/2020/12/01/node/node14_storage/</id>
    <published>2020-12-01T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Node.js Async Hooks 模块提供了 API 用来追踪 Node.js 程序中异步资源的声明周期，在最新的 v14.x LTS 版本中新增加了一个 AsyncLocalStorage 类可以方便实现上下文本地存储，在异步调用之间共享数据，对于实现日志链路追踪场景很有用。</p></blockquote><p>下面是一个 HTTP 请求的简单示例，模拟了异步处理，并且在日志输出时去追踪存储的 id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const &#123; AsyncLocalStorage &#125; &#x3D; require(&#39;async_hooks&#39;);</span><br><span class="line">const asyncLocalStorage &#x3D; new AsyncLocalStorage();</span><br><span class="line">function logWithId(msg) &#123;</span><br><span class="line">    const id &#x3D; asyncLocalStorage.getStore();</span><br><span class="line">    console.log(&#96;$&#123;id !&#x3D;&#x3D; undefined ? id : &#39;-&#39;&#125;:&#96;, msg);</span><br><span class="line">&#125;</span><br><span class="line">let idSeq &#x3D; 0;</span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">asyncLocalStorage.run(idSeq++, () &#x3D;&gt; &#123;</span><br><span class="line">    logWithId(&#39;start&#39;);</span><br><span class="line">    setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    logWithId(&#39;processing...&#39;);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    logWithId(&#39;finish&#39;);</span><br><span class="line">    res.end();</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/eb52f62e37dddeddcbf686d8841675c7.png" alt="RUNOOB 图标"></p><p>注意：便利性的同时也会牺牲一些性能上的代价。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Node.js Async Hooks 模块提供了 API 用来追踪 Node.js 程序中异步资源的声明周期，在最新的 v14.x LTS 版本中新增加了一个 AsyncLocalStorage 类可以方便实现上下文本地存储，在异步调用之间共享数</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 14 特性 Intl.DateTimeFormat（国际化处理日期时间格式）</title>
    <link href="http://www.haleyl.com/2020/11/20/node/node14_data/"/>
    <id>http://www.haleyl.com/2020/11/20/node/node14_data/</id>
    <published>2020-11-20T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.410Z</updated>
    
    <content type="html"><![CDATA[<p>Intl.DateTimeFormat API 用来处理特定语言环境的日期格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const date &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sunday, January 10, 2021 at 9:02:29 PM GMT+8</span><br><span class="line">new Intl.DateTimeFormat(&#39;en-US&#39;, &#123; dateStyle: &#39;full&#39;, timeStyle: &#39;long&#39;&#125;).format(date)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 21&#x2F;1&#x2F;10 中国标准时间 下午9:02:29.315</span><br><span class="line">new Intl.DateTimeFormat(&#39;zh-CN&#39;, &#123;</span><br><span class="line">year: &#39;2-digit&#39;,</span><br><span class="line">month: &#39;numeric&#39;,</span><br><span class="line">day: &#39;numeric&#39;,</span><br><span class="line">hour: &#39;numeric&#39;,</span><br><span class="line">minute: &#39;numeric&#39;,</span><br><span class="line">second: &#39;numeric&#39;,</span><br><span class="line">fractionalSecondDigits: 3,</span><br><span class="line">timeZoneName: &#39;long&#39;</span><br><span class="line">&#125;).format(date)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Intl.DateTimeFormat API 用来处理特定语言环境的日期格式。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 14 特性 Intl.DisplayNames</title>
    <link href="http://www.haleyl.com/2020/11/09/node/node14_lang/"/>
    <id>http://www.haleyl.com/2020/11/09/node/node14_lang/</id>
    <published>2020-11-09T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.411Z</updated>
    
    <content type="html"><![CDATA[<p>Intl.DisplayNames（国际化显示名称）<br>对于国际化应用需要用到的语言、区域、货币、脚本的名称，现在 JavaScript 开发者可以使用 Intl.DisplayNames API 直接访问这些翻译，使应用程序更轻松的显示本地化名称。</p><h3 id="Language（语言）"><a href="#Language（语言）" class="headerlink" title="Language（语言）"></a>Language（语言）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let longLanguageNames &#x3D; new Intl.DisplayNames([&#39;zh-CN&#39;], &#123; type: &#39;language&#39; &#125;);</span><br><span class="line">longLanguageNames.of(&#39;en-US&#39;); &#x2F;&#x2F; 美国英语</span><br><span class="line">longLanguageNames.of(&#39;zh-CN&#39;); &#x2F;&#x2F; 中文（中国）</span><br><span class="line"></span><br><span class="line">longLanguageNames &#x3D; new Intl.DisplayNames([&#39;en&#39;], &#123; type: &#39;language&#39; &#125;);</span><br><span class="line">longLanguageNames.of(&#39;en-US&#39;); &#x2F;&#x2F; American English</span><br><span class="line">longLanguageNames.of(&#39;zh-CN&#39;); &#x2F;&#x2F; Chinese (China)</span><br></pre></td></tr></table></figure><h3 id="Region（区域）"><a href="#Region（区域）" class="headerlink" title="Region（区域）"></a>Region（区域）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let regionNames &#x3D; new Intl.DisplayNames([&#39;zh-CN&#39;], &#123;type: &#39;region&#39;&#125;);</span><br><span class="line">regionNames.of(&#39;US&#39;); &#x2F;&#x2F; 美国</span><br><span class="line">regionNames.of(&#39;419&#39;); &#x2F;&#x2F; 拉丁美洲</span><br><span class="line"></span><br><span class="line">regionNames &#x3D; new Intl.DisplayNames([&#39;en&#39;], &#123;type: &#39;region&#39;&#125;);</span><br><span class="line">regionNames.of(&#39;US&#39;); &#x2F;&#x2F; United States</span><br><span class="line">regionNames.of(&#39;419&#39;); &#x2F;&#x2F; Latin America</span><br></pre></td></tr></table></figure><h3 id="Currency（货币）"><a href="#Currency（货币）" class="headerlink" title="Currency（货币）"></a>Currency（货币）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let currencyNames &#x3D; new Intl.DisplayNames([&#39;zh-CN&#39;], &#123;type: &#39;currency&#39;&#125;);</span><br><span class="line">currencyNames.of(&#39;CNY&#39;); &#x2F;&#x2F; 人民币</span><br><span class="line">currencyNames.of(&#39;USD&#39;); &#x2F;&#x2F; 美元</span><br><span class="line"></span><br><span class="line">currencyNames &#x3D; new Intl.DisplayNames([&#39;en&#39;], &#123;type: &#39;currency&#39;&#125;);</span><br><span class="line">currencyNames.of(&#39;CNY&#39;); &#x2F;&#x2F; Chinese Yuan</span><br><span class="line">currencyNames.of(&#39;USD&#39;); &#x2F;&#x2F; US Dollar</span><br></pre></td></tr></table></figure><h3 id="Script（脚本）"><a href="#Script（脚本）" class="headerlink" title="Script（脚本）"></a>Script（脚本）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let scriptNames &#x3D; new Intl.DisplayNames([&#39;zh-CN&#39;], &#123;type: &#39;script&#39;&#125;);</span><br><span class="line">scriptNames.of(&#39;Hans&#39;); &#x2F;&#x2F; 简体</span><br><span class="line">scriptNames.of(&#39;Latn&#39;); &#x2F;&#x2F; 拉丁文</span><br><span class="line"></span><br><span class="line">scriptNames &#x3D; new Intl.DisplayNames([&#39;en&#39;], &#123;type: &#39;script&#39;&#125;);</span><br><span class="line">scriptNames.of(&#39;Hans&#39;); &#x2F;&#x2F; Simplified</span><br><span class="line">scriptNames.of(&#39;Latn&#39;); &#x2F;&#x2F; Latin</span><br></pre></td></tr></table></figure><p>参考：<a href="https://v8.dev/features/intl-displaynames">https://v8.dev/features/intl-displaynames</a></p><p>上述实例用到的国家代号和 code 都可从参考地址获取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Intl.DisplayNames（国际化显示名称）&lt;br&gt;对于国际化应用需要用到的语言、区域、货币、脚本的名称，现在 JavaScript 开发者可以使用 Intl.DisplayNames API 直接访问这些翻译，使应用程序更轻松的显示本地化名称。&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 14 特性 Nullish Coalescing（空值合并）</title>
    <link href="http://www.haleyl.com/2020/11/08/node/node14_nullish/"/>
    <id>http://www.haleyl.com/2020/11/08/node/node14_nullish/</id>
    <published>2020-11-08T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.411Z</updated>
    
    <content type="html"><![CDATA[<p>逻辑或操作符（||）会在左侧为假值时返回右侧的操作符，例如我们传入一个属性为 enabled:0 我们期望输出左侧的值，则是不行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Component(props) &#123;</span><br><span class="line">  const enable &#x3D; props.enabled || true; &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br><span class="line">Component(&#123; enabled: 0 &#125;)</span><br></pre></td></tr></table></figure><p>现在我们可以使用 <strong>空值合并操作符（??）</strong>来实现，仅当左侧为 undefined 或 null 时才返回右侧的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Component(props) &#123;</span><br><span class="line">  const enable &#x3D; props.enabled ?? true; &#x2F;&#x2F; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component(&#123; enabled: 0 &#125;)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://v8.dev/features/nullish-coalescing">https://v8.dev/features/nullish-coalescing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;逻辑或操作符（||）会在左侧为假值时返回右侧的操作符，例如我们传入一个属性为 enabled:0 我们期望输出左侧的值，则是不行的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 14 特性 Optional Chaining（可选链）</title>
    <link href="http://www.haleyl.com/2020/11/05/node/node14_optional_chaining/"/>
    <id>http://www.haleyl.com/2020/11/05/node/node14_optional_chaining/</id>
    <published>2020-11-05T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><p>如果我们使用 JavaScript 不管是用在前端或者 Node.js 服务端都会出现如下情况，因为我们有时是不确定 user 对象是否存在，又或者 user 对象里面的 address 是否存在，如果不这样判断， 可能会得到类似于 Cannot read property ‘xxx’ of undefined 这样的类似错误。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">  name: &#39;Haley&#39;,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: &#39;GuangZhou&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">optionalChaining()&#123;</span><br><span class="line">    if (this.user.address.city1.length &gt; 0)&#123;</span><br><span class="line">      alert(&quot;原先写法触发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们有一种优雅的写法 “可选链操作符”，不必明确的验证链中的每个引用是否有效，以符号 “?.” 表示，在引用为 null 或 undefined 时不会报错，会发生短路返回 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">optionalChaining()&#123;</span><br><span class="line">    if (this.user.address?.city1?.length &gt; 0)&#123;</span><br><span class="line">      alert(&quot;新特性触发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">user.address?.city</span><br><span class="line">user.address?.city?.length</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 结合 ?.[] 的方式访问相当于 user.address[&#39;city&#39;]</span><br><span class="line">user.address?.[&#39;city&#39;]</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 结合 delete 语句使用，仅在 user.address.city 存在才删除</span><br><span class="line">delete user.address?.city</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果我们使用 JavaScript 不管是用在前端或者 Node.js 服务端都会出现如下情况，因为我们有时是不确定 user 对</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 14 特性 诊断报告</title>
    <link href="http://www.haleyl.com/2020/11/03/node/node14_report/"/>
    <id>http://www.haleyl.com/2020/11/03/node/node14_report/</id>
    <published>2020-11-03T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.413Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://nodejs.cn/api/report.html">诊断报告用法</a><br><a href="https://cloud.tencent.com/developer/article/1780509">在 Node.js 中使用诊断报告快速追踪问题</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://nodejs.org/dist/latest-v12.x/docs/api/report.html">https://nodejs.org/dist/latest-v12.x/docs/api/report.html</a></li><li><a href="https://ibm.github.io/report-toolkit/quick-start">https://ibm.github.io/report-toolkit/quick-start</a></li><li><a href="https://developer.ibm.com/technologies/node-js/articles/introducing-report-toolkit-for-nodejs-diagnostic-reports">https://developer.ibm.com/technologies/node-js/articles/introducing-report-toolkit-for-nodejs-diagnostic-reports</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/report.html&quot;&gt;诊断报告用法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1780509&quot;&gt;在 Node.js 中使用诊断报告快</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 14 特性</title>
    <link href="http://www.haleyl.com/2020/10/05/node/node14/"/>
    <id>http://www.haleyl.com/2020/10/05/node/node14/</id>
    <published>2020-10-05T03:10:04.000Z</published>
    <updated>2021-03-31T09:08:59.410Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js 14版本于近日正式发布， 此版本包含的亮点如下：</p><ul><li><a href="/2020/11/03/node/node14_report/">对诊断功能的改进</a></li><li><a href="#">升级v8引擎</a><ul><li><a href="/2020/11/05/node/node14_optional_chaining/">可选链</a></li><li><a href="/2020/11/08/node/node14_nullish/">Nullish合并</a></li><li><a href="/2020/11/09/node/node14_lang/">Intl.DisplayNamess</a></li><li><a href="/2020/11/20/node/node14_data/">Intl.DateTimeFormat（国际化处理日期时间格式）</a></li></ul></li><li><a href="/2020/12/01/node/node14_storage/">新增实验性的异步本地存储API</a></li><li><a href="#">强化流API</a></li><li><a href="#">移除实验性模块中的警告</a></li><li><a href="http://nodejs.cn/api/deprecations.html">移除一部分早期版本中废弃的API</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Node.js 14版本于近日正式发布， 此版本包含的亮点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/11/03/node/node14_report/&quot;&gt;对诊断功能的改进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;升级v8引擎&lt;/a&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
    <category term="node" scheme="http://www.haleyl.com/tags/node/"/>
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>数据库慢查询 - count</title>
    <link href="http://www.haleyl.com/2018/05/13/mysql/mysql-count/"/>
    <id>http://www.haleyl.com/2018/05/13/mysql/mysql-count/</id>
    <published>2018-05-13T10:24:35.000Z</published>
    <updated>2021-04-27T09:33:38.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在业务处理过程中，在表数据量庞大的情况下。我们会需要一个问题就是分页/获取总数的情况。其中一查有的同学就会知道时不时出现个慢查询的警报，头疼不已。你肯定想屏蔽群了。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>show table status - 针对不太要求实时性</li><li>分页不展示总数，具体可参数谷歌分页做法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;在业务处理过程中，在表数据量庞大的情况下。我们会需要一个问题就是分页/获取总数的情况。其中一查有的同学就会知道时不时出现个慢查询的警报，头疼</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="mysql" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/mysql/"/>
    
    
    <category term="mysql" scheme="http://www.haleyl.com/tags/mysql/"/>
    
    <category term="count" scheme="http://www.haleyl.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>数据库order by 无序</title>
    <link href="http://www.haleyl.com/2018/04/15/mysql/mysql-order/"/>
    <id>http://www.haleyl.com/2018/04/15/mysql/mysql-order/</id>
    <published>2018-04-15T10:24:35.000Z</published>
    <updated>2021-04-27T08:33:53.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>数据分页时需要根据数据记录sort字段倒序，即使用order by sort desc limit ?,?，但是我们会发现，前端进行请求时获取的数据并不正确，分页中出现了一定的重复数据。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果没有指定ORDER BY语句，则 MySQL （或任何RDBMS）不保证以特定顺序返回结果。 有些人认为，如果没有指定order by子句，行总是以聚簇索引顺序或物理磁盘顺序返回。 然而，这是不正确的，因为在查询处理期间可以改变行顺序的许多因素，例如并行的HASH连接是更改行顺序的操作符的一个很好的例子。<br>如果指定ORDER BY语句，MySQL将对行进行排序，并按请求的顺序返回。 但是，如果该顺序不是确定性的，即可能有重复的值，则在每个具有相同值的组中，由于与上述相同的原因，该顺序是“随机的”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;数据分页时需要根据数据记录sort字段倒序，即使用order by sort desc limit ?,?，但是我们会发现，前端进行请求时获</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="mysql" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/mysql/"/>
    
    
    <category term="mysql" scheme="http://www.haleyl.com/tags/mysql/"/>
    
    <category term="order" scheme="http://www.haleyl.com/tags/order/"/>
    
  </entry>
  
  <entry>
    <title>vue-seamless-scroll在vue3.0引入</title>
    <link href="http://www.haleyl.com/2018/03/22/vue/vue-scroll/"/>
    <id>http://www.haleyl.com/2018/03/22/vue/vue-scroll/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2021-03-31T09:08:59.414Z</updated>
    
    <content type="html"><![CDATA[<p>背景：vue-seamless-scroll 是目前vue无限滚动插件中相对比较好用的一个。刚好项目需要做个列表无限滚动。</p><p>官方参考文档：<a href="https://chenxuan0000.github.io/vue-seamless-scroll/zh/guide/">https://chenxuan0000.github.io/vue-seamless-scroll/zh/guide/</a></p><blockquote><p>在官方文档中，未涉及到对createApp的引用。为此展示代码给予参考</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;vue-seamless-scroll :data&#x3D;&quot;listData&quot;  :class-option&#x3D;&quot;classOption&quot; class&#x3D;&quot;seamless-warp&quot;&gt;</span><br><span class="line">  &lt;ul id&#x3D;&quot;ul1&quot; class&#x3D;&quot;item&quot; &gt;</span><br><span class="line">     &lt;li v-for&#x3D;&quot;item in listData&quot; v-bind:key&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;vue-seamless-scroll&gt;</span><br><span class="line"> </span><br><span class="line">import vueSeamlessScroll from &#39;vue-seamless-scroll&#x2F;src&#39;</span><br><span class="line"></span><br><span class="line">setup()&#123;</span><br><span class="line">    const classOption &#x3D; () &#x3D;&gt;&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            step:0.2,&#x2F;&#x2F;数值越大滚动越快</span><br><span class="line">            direction: 2,&#x2F;&#x2F;滚动方向：0:向下，1：向上，2：向左，3：向右</span><br><span class="line">            limitMoveNum: 100,&#x2F;&#x2F;数据量：listData.length</span><br><span class="line">            hoverStop:true,&#x2F;&#x2F;是否开启鼠标悬停stop</span><br><span class="line">            openWatch:true,&#x2F;&#x2F;开启数据时监控刷新dom</span><br><span class="line">            singleHeight: 0, &#x2F;&#x2F; 单步运动停止的高度(默认值0是无缝不停止的滚动) direction &#x3D;&gt; 0&#x2F;1</span><br><span class="line"></span><br><span class="line">            singleWidth:0,&#x2F;&#x2F; 单步运动停止的宽度(默认值0是无缝不停止的滚动) direction &#x3D;&gt; 2&#x2F;3</span><br><span class="line">            waitTime:1000&#x2F;&#x2F; 单步运动停止的时间(默认值1000ms)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      classOption</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;背景：vue-seamless-scroll 是目前vue无限滚动插件中相对比较好用的一个。刚好项目需要做个列表无限滚动。&lt;/p&gt;
&lt;p&gt;官方参考文档：&lt;a href=&quot;https://chenxuan0000.github.io/vue-seamless-scroll/z</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
    <category term="vue" scheme="http://www.haleyl.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>数据库优化之加索引语句不加锁</title>
    <link href="http://www.haleyl.com/2018/02/02/mysql/mysql-blok/"/>
    <id>http://www.haleyl.com/2018/02/02/mysql/mysql-blok/</id>
    <published>2018-02-02T01:24:35.000Z</published>
    <updated>2021-03-31T04:01:58.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线上无锁添加索引：加索引的语句不加锁<br>ALGORITHM=INPLACE, LOCK=NONE</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (<span class="keyword">column</span>), ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure><blockquote><p>ALGORITHM=INPLACE<br>更优秀的解决方案，在当前表加索引，步骤：<br>1.创建索引(二级索引)数据字典<br>2.加共享表锁，禁止DML，允许查询<br>3.读取聚簇索引，构造新的索引项，排序并插<br>入新索引<br>4.等待打开当前表的所有只读事务提交<br>5.创建索引结束</p></blockquote><blockquote><p>ALGORITHM=COPY<br>通过临时表创建索引，需要多一倍存储，还有更多的IO，步骤：<br>1.新建带索引（主键索引）的临时表<br>2.锁原表，禁止DML，允许查询<br>3.将原表数据拷贝到临时表<br>4.禁止读写,进行rename，升级字典锁<br>5.完成创建索引操作</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOCK=DEFAULT：默认方式，MySQL自行判断使用哪种LOCK模式，尽量不锁表</span><br><span class="line">LOCK=NONE：无锁：允许Online DDL期间进行并发读写操作。如果Online DDL操</span><br><span class="line">作不支持对表的继续写入，则DDL操作失败，对表修改无效</span><br><span class="line">LOCK=SHARED：共享锁：Online DDL操作期间堵塞写入，不影响读取</span><br><span class="line">LOCK=EXCLUSIVE：排它锁：Online DDL操作期间不允许对锁表进行任何操作</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线上无锁添加索引：加索引的语句不加锁&lt;br&gt;ALGORITHM=INPLACE, LOCK=NONE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="mysql" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/mysql/"/>
    
    
    <category term="mysql" scheme="http://www.haleyl.com/tags/mysql/"/>
    
    <category term="优化" scheme="http://www.haleyl.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装Beego：go install: cannot install cross-compiled binaries when GOBIN is set</title>
    <link href="http://www.haleyl.com/2018/01/15/go/go-bee-install/"/>
    <id>http://www.haleyl.com/2018/01/15/go/go-bee-install/</id>
    <published>2018-01-15T03:14:41.000Z</published>
    <updated>2021-03-31T04:01:58.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下安装Beego出错"><a href="#Linux下安装Beego出错" class="headerlink" title="Linux下安装Beego出错"></a>Linux下安装Beego出错</h1><h2 id="问题：go-install-cannot-install-cross-compiled-binaries-when-GOBIN-is-set"><a href="#问题：go-install-cannot-install-cross-compiled-binaries-when-GOBIN-is-set" class="headerlink" title="问题：go install: cannot install cross-compiled binaries when GOBIN is set"></a>问题：go install: cannot install cross-compiled binaries when GOBIN is set</h2><p>遇到这个问题一般是在环境变量中设置了 GOBIN 可以打开 /etc/profile 把这个变量注释掉就，执行 source /etc/profile生效即可同样安装完成之后需要在环境变量中追加bee的路径</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ol><li>注释GOBIN选项，并在 /etc/profile 文件中设置GOPATH/bin（永久）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$GOPATH&#x2F;bin:$PATH </span><br></pre></td></tr></table></figure><p>重新生成配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>可能遇到的问题：添加之后执行bee不成功。<br>查看bee的所在路径 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $GOPATH &#x2F;&#x2F;获取GOPATH的路径 本人是在&#x2F;data&#x2F;www&#x2F;go:</span><br><span class="line">find &#x2F;home&#x2F;chun&#x2F;go -name &quot;bee&quot; &#x2F;&#x2F;查找目录的含bee的文件夹</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;data&#x2F;www&#x2F;go&#x2F;bin&#x2F;linux_386&#x2F;bee</span><br><span class="line">&#x2F;data&#x2F;www&#x2F;go&#x2F;src&#x2F;github.com&#x2F;beego&#x2F;bee</span><br><span class="line">&#x2F;data&#x2F;www&#x2F;go&#x2F;pkg&#x2F;linux_386&#x2F;github.com&#x2F;beego&#x2F;bee</span><br></pre></td></tr></table></figure><p>这里可以看到我的linux系统上bee的安装路径和正常不一样，在linux_386下面，接下来只需把/home/chun/go/bin/linux_386添加到环境变量就ok了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$GOPATH&#x2F;bin&#x2F;linux_386:$PATH</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><ol start="2"><li>在GOPATH下删除GOBIN设置（暂时）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $GOPATH</span><br><span class="line">unset GOBIN</span><br></pre></td></tr></table></figure><blockquote><p>交流沟通：QQ群866437035<br><img src="https://img-blog.csdnimg.cn/20190220114346945.jpg" alt="在这里插入图片描述"> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux下安装Beego出错&quot;&gt;&lt;a href=&quot;#Linux下安装Beego出错&quot; class=&quot;headerlink&quot; title=&quot;Linux下安装Beego出错&quot;&gt;&lt;/a&gt;Linux下安装Beego出错&lt;/h1&gt;&lt;h2 id=&quot;问题：go-install</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go" scheme="http://www.haleyl.com/tags/go/"/>
    
    <category term="bee" scheme="http://www.haleyl.com/tags/bee/"/>
    
    <category term="beego" scheme="http://www.haleyl.com/tags/beego/"/>
    
    <category term="gobin" scheme="http://www.haleyl.com/tags/gobin/"/>
    
  </entry>
  
  <entry>
    <title>axios的post请求后台（ThinkPHP5）接收不到数据</title>
    <link href="http://www.haleyl.com/2017/12/05/vue/vue-ajax/"/>
    <id>http://www.haleyl.com/2017/12/05/vue/vue-ajax/</id>
    <published>2017-12-05T03:10:04.000Z</published>
    <updated>2021-03-31T04:01:58.063Z</updated>
    
    <content type="html"><![CDATA[<p>最近做vue项目，做分页的功能，使用post给后台发送数据，使用接口还是工具（postman）都可获取数据，唯独axios获取不到；经过排除，发现这与axios的post传参格式有关系；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> this.$axios(&#123;</span><br><span class="line">    method: &#39;post&#39;,</span><br><span class="line">    url:url,</span><br><span class="line">    params: &#123;</span><br><span class="line">        seller_id:seller_id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then((res)&#x3D;&gt;&#123;</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在使用axios时，要注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。而data（form-data）是添加到请求体（body）中的， 用于post请求。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p>配置如下：<br>在main.js里 设置配置，修改Content-Type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;;</span><br><span class="line">axios.defaults.headers.post[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;x-www-form-urlencoded&#39;;</span><br><span class="line">Vue.prototype.$axios &#x3D; axios;</span><br></pre></td></tr></table></figure><blockquote><p>Content-Type须配置为application/x-www-form-urlencoded，以数据量格式进行数据传输（不兼容ie）</p></blockquote><h3 id="方法2：（推荐）"><a href="#方法2：（推荐）" class="headerlink" title="方法2：（推荐）"></a>方法2：（推荐）</h3><p>安装qs,在 main.js里引入并且对数据进行序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;;</span><br><span class="line">import qs from &#39;qs&#39;;</span><br><span class="line">Vue.prototype.$qs &#x3D; qs;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import qs from &#39;qs&#39;;</span><br><span class="line">axios.interceptors.request.use((config) &#x3D;&gt; &#123;</span><br><span class="line">    config.data &#x3D; qs.stringify(config.data);</span><br><span class="line">    return config;</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做vue项目，做分页的功能，使用post给后台发送数据，使用接口还是工具（postman）都可获取数据，唯独axios获取不到；经过排除，发现这与axios的post传参格式有关系；&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="前端" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="http://www.haleyl.com/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
    <category term="js" scheme="http://www.haleyl.com/tags/js/"/>
    
    <category term="vue" scheme="http://www.haleyl.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习之路：异常处理defer，panic，recover</title>
    <link href="http://www.haleyl.com/2017/11/23/go/go-fail/"/>
    <id>http://www.haleyl.com/2017/11/23/go/go-fail/</id>
    <published>2017-11-22T19:19:20.000Z</published>
    <updated>2021-03-31T09:08:59.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go没有像Java那样的异常机制，它不能抛出异常。因为设计者们认为，将异常与控制结构混在一起容易使得代码变得混乱。于是乎引入Exception处理-defer-panic-recover"><a href="#Go没有像Java那样的异常机制，它不能抛出异常。因为设计者们认为，将异常与控制结构混在一起容易使得代码变得混乱。于是乎引入Exception处理-defer-panic-recover" class="headerlink" title="Go没有像Java那样的异常机制，它不能抛出异常。因为设计者们认为，将异常与控制结构混在一起容易使得代码变得混乱。于是乎引入Exception处理: defer,panic,recover;"></a>Go没有像Java那样的异常机制，它不能抛出异常。因为设计者们认为，将异常与控制结构混在一起容易使得代码变得混乱。于是乎引入Exception处理: defer,panic,recover;</h2><blockquote><p>简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p></blockquote><p>例子代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func demo()&#123;</span><br><span class="line">fmt.Println(&quot;Welcome, my name is fudomine&quot;)</span><br><span class="line">panic(400)</span><br><span class="line">fmt.Println(&quot;Hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">defer func()&#123;</span><br><span class="line">fmt.Println(&quot;defer start&quot;)</span><br><span class="line">errorMsg :&#x3D; recover()</span><br><span class="line">fmt.Println(&quot;Error msg :&quot;, errorMsg)</span><br><span class="line">fmt.Println(&quot;defer end&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">demo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://img-blog.csdn.net/20180629150930893?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果"></p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer 英文原意： vi. 推迟；延期；服从   vt. 使推迟；使延期。</p><ul><li>Go语言中内置函数；类似于C/PHP的析构函数，但它不是针对对象而是函数；</li><li>允许在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回（类似堆栈，先进后出）。</li><li>调用时须在程序结束前调用，简单来说让defer语句在return/panic前写入至内存中;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func demo()(str string)&#123;</span><br><span class="line">str &#x3D; &quot;Hello&quot;</span><br><span class="line">defer func() &#123;</span><br><span class="line">str &#x3D; &quot;Welcome, my  name is fudomine&quot;</span><br><span class="line">&#125;()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：Welcome, my name is fudomine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func demo()(str string)&#123;</span><br><span class="line">str &#x3D; &quot;Hello&quot;</span><br><span class="line">return</span><br><span class="line">defer func() &#123;</span><br><span class="line">str &#x3D; &quot;Welcome, my  name is fudomine&quot;</span><br><span class="line">&#125;()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：Hello</p><p>可能会有小伙伴自己编写代码后，答案不一致；为此特贴出不一样结果的例子代码并进行分析；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func demo()(string)&#123;</span><br><span class="line">str :&#x3D; &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">str &#x3D; &quot;Welcome, my  name is fudomine&quot;</span><br><span class="line">&#125;()</span><br><span class="line">return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：defer 中return xxx这一条语句并不是一条原子指令，而上面结果是因为初始化时候就声明输出类型是*T(指针)；</p><blockquote><p>拆分为：</p><ul><li>返回值 = xxx</li></ul></blockquote><ul><li>调用defer函数</li><li>空的return<br>详细请参考下<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html">《深入解析GO》</a>一文</li></ul><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>panic 英文原意：n. 恐慌，惊慌；大恐慌  adj. 恐慌的；没有理由的  vt. 使恐慌  vi. 十分惊慌</p><ul><li>Go是一个内建函数，可以中断原有的控制流程，进入一个异常的流程中。当函数 Func 调用 panic ，函数Func 的执行被中断，但是 Func  中的延迟函数会正常执行，然后Func 返回到调用它的地方。在调用的地方， Func  的行为就像调用了 panic 。这一过程继续向上(只有刚才defer寸在内存中，将会被调用)，直到发生 panic 的 goroutine 中所有调用的函数返回，此时程序退出。</li></ul><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>recover 英文原意： vt. 恢复；弥补；重新获得   vi. 恢复；胜诉；重新得球   n. 还原至预备姿势</p><ul><li>Go是一个内建的函数，可以让进入令人恐慌的流程中的 goroutine 恢复过来。 recover 仅在延迟函数中有效。在正常的执行过程中，调用 recover 会返回 nil ，并且没有其它任何效果。如果当前的 goroutine 陷入恐慌，调用recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</li></ul><p>参考文献<br>《go web编程》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go没有像Java那样的异常机制，它不能抛出异常。因为设计者们认为，将异常与控制结构混在一起容易使得代码变得混乱。于是乎引入Exception处理-defer-panic-recover&quot;&gt;&lt;a href=&quot;#Go没有像Java那样的异常机制，它不能抛出异常。因为</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go" scheme="http://www.haleyl.com/tags/go/"/>
    
    <category term="异常处理" scheme="http://www.haleyl.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
    <category term="defer" scheme="http://www.haleyl.com/tags/defer/"/>
    
    <category term="painc" scheme="http://www.haleyl.com/tags/painc/"/>
    
    <category term="recover" scheme="http://www.haleyl.com/tags/recover/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习之路：引用类型与值类型</title>
    <link href="http://www.haleyl.com/2017/10/03/go/go-val/"/>
    <id>http://www.haleyl.com/2017/10/03/go/go-val/</id>
    <published>2017-10-03T15:19:20.000Z</published>
    <updated>2021-03-31T04:01:58.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Golang中只有三种引用类型：slice-切片-、map-字典-、channel-管道-；"><a href="#Golang中只有三种引用类型：slice-切片-、map-字典-、channel-管道-；" class="headerlink" title="Golang中只有三种引用类型：slice(切片)、map(字典)、channel(管道)；"></a>Golang中只有三种引用类型：slice(切片)、map(字典)、channel(管道)；</h4><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li><strong>引用类型理解为（C语言）：指针</strong></li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul><li>值的拷贝</li></ul><p>下面以值类型和slice(切片)例子可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">a :&#x3D; [5]int&#123;2, 3, 4, 5, 6&#125;</span><br><span class="line">b :&#x3D; a</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">b[2] &#x3D; 77</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个数组a，它是值类型，复制给b是copy，当b发生变化后a并不会发生任何变化，结果如下：<br><img src="https://img-blog.csdn.net/20180628152152653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="值类型"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">a :&#x3D; []int&#123;2, 3, 4, 5, 6&#125;</span><br><span class="line">b :&#x3D; a</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">b[2] &#x3D; 77</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个数组a，它是引用类型（slice切片），被b引用（指针）后，当b发生变化后a也发生任何变化，结果如下：<br><img src="https://img-blog.csdn.net/20180628152701354?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="引用类型"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Golang中只有三种引用类型：slice-切片-、map-字典-、channel-管道-；&quot;&gt;&lt;a href=&quot;#Golang中只有三种引用类型：slice-切片-、map-字典-、channel-管道-；&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go" scheme="http://www.haleyl.com/tags/go/"/>
    
    <category term="引用类型" scheme="http://www.haleyl.com/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="值类型" scheme="http://www.haleyl.com/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习之路：Println 与 Printf 的区别</title>
    <link href="http://www.haleyl.com/2017/09/01/go/go-fmt/"/>
    <id>http://www.haleyl.com/2017/09/01/go/go-fmt/</id>
    <published>2017-09-01T02:19:20.000Z</published>
    <updated>2021-03-31T09:08:59.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Println-和Printf-都是fmt包中公共方法；在需要打印信息时常用的函数，那么二函数有什么区别呢？"><a href="#Println-和Printf-都是fmt包中公共方法；在需要打印信息时常用的函数，那么二函数有什么区别呢？" class="headerlink" title="Println 和Printf 都是fmt包中公共方法；在需要打印信息时常用的函数，那么二函数有什么区别呢？"></a>Println 和Printf 都是fmt包中公共方法；在需要打印信息时常用的函数，那么二函数有什么区别呢？</h3><h5 id="附上代码"><a href="#附上代码" class="headerlink" title="附上代码"></a>附上代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;time&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">Man &#x3D; 1</span><br><span class="line">Female &#x3D; 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">timer :&#x3D; time.Now().Unix()</span><br><span class="line">if(timer % Female &#x3D;&#x3D; 0)&#123;</span><br><span class="line">fmt.Println(&quot;%d is Female&quot;, timer)</span><br><span class="line">fmt.Printf(&quot;%d is Female&quot;, timer)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;%d is Man&quot;, timer)</span><br><span class="line">fmt.Printf(&quot;%d is Man&quot;, timer)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%d is Man 1529049077 &#x2F;&#x2F; println输出结果</span><br><span class="line">1529049077 is Man &#x2F;&#x2F; printf输出结果</span><br></pre></td></tr></table></figure><h5 id="结果可知"><a href="#结果可知" class="headerlink" title="结果可知"></a>结果可知</h5><blockquote><p><strong>Printf</strong> : 可打印出格式化的字符串,<strong>Println</strong>不行；</p></blockquote><h5 id="稍做修改下"><a href="#稍做修改下" class="headerlink" title="稍做修改下"></a>稍做修改下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">StrN &#x3D; &quot;123&quot;</span><br><span class="line">IntN &#x3D; 123</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">fmt.Println(StrN)</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;,StrN)</span><br><span class="line">fmt.Printf(StrN)</span><br><span class="line">fmt.Println(IntN)</span><br><span class="line">fmt.Printf(&quot;%d\n&quot;,IntN)</span><br><span class="line">fmt.Printf(IntN)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><blockquote><p><img src="https://img-blog.csdn.net/20180615160607803?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="https://img-blog.csdn.net/20180615160924183?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180615160932122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>看到源码内容，相信你大致明白两函数的区别了吧~；<br>总结一句话： println会根据你输入格式原样输出，printf需要格式化输出并带输出格式；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Println-和Printf-都是fmt包中公共方法；在需要打印信息时常用的函数，那么二函数有什么区别呢？&quot;&gt;&lt;a href=&quot;#Println-和Printf-都是fmt包中公共方法；在需要打印信息时常用的函数，那么二函数有什么区别呢？&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go" scheme="http://www.haleyl.com/tags/go/"/>
    
    <category term="fmt" scheme="http://www.haleyl.com/tags/fmt/"/>
    
    <category term="println" scheme="http://www.haleyl.com/tags/println/"/>
    
    <category term="printf" scheme="http://www.haleyl.com/tags/printf/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习之路：new和make的区别</title>
    <link href="http://www.haleyl.com/2017/08/05/go/go-mark/"/>
    <id>http://www.haleyl.com/2017/08/05/go/go-mark/</id>
    <published>2017-08-05T02:19:20.000Z</published>
    <updated>2021-03-31T09:08:59.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言中new跟make是内置函数，主要用来创建分配类型内存。</p></blockquote><h3 id="new"><a href="#new" class="headerlink" title="new( )"></a>new( )</h3><p>new(T)创建一个没有任何数据的类型为T的实例，并返回该实例的指针；</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func new</span><br><span class="line">func new(Type) *Type</span><br><span class="line">The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make( )"></a>make( )</h3><p>make(T, args)只能创建 slice、map和channel，并且返回一个有初始值args（非零）的T类型的实例，非指针。</p><h4 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func make</span><br><span class="line">func make(Type, size IntegerType) Type</span><br><span class="line">The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make&#39;s return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</span><br><span class="line"></span><br><span class="line">Slice: The size specifies the length. The capacity of the slice is</span><br><span class="line">equal to its length. A second integer argument may be provided to</span><br><span class="line">specify a different capacity; it must be no smaller than the</span><br><span class="line">length, so make([]int, 0, 10) allocates a slice of length 0 and</span><br><span class="line">capacity 10.</span><br><span class="line">Map: An empty map is allocated with enough space to hold the</span><br><span class="line">specified number of elements. The size may be omitted, in which case</span><br><span class="line">a small starting size is allocated.</span><br><span class="line">Channel: The channel&#39;s buffer is initialized with the specified</span><br><span class="line">buffer capacity. If zero, or the size is omitted, the channel is</span><br><span class="line">unbuffered.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二者异同"><a href="#二者异同" class="headerlink" title="二者异同"></a>二者异同</h3><p>二者都是内存的分配（堆上），但是<code>make</code>只用于slice、map以及channel的初始化（非零值）；而<code>new</code>用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。</p><p><code>make</code>返回的还是这三个引用类型本身；而<code>new</code>返回的是指向类型的指针。</p><blockquote><p>交流沟通：QQ群866437035<br><img src="https://img-blog.csdnimg.cn/20190220114346945.jpg" alt="在这里插入图片描述"> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Go语言中new跟make是内置函数，主要用来创建分配类型内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new( )&quot;&gt;&lt;/a&gt;new( )&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go" scheme="http://www.haleyl.com/tags/go/"/>
    
    <category term="new" scheme="http://www.haleyl.com/tags/new/"/>
    
    <category term="mark" scheme="http://www.haleyl.com/tags/mark/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 自带时间处理函数</title>
    <link href="http://www.haleyl.com/2017/07/04/php/php-timer/"/>
    <id>http://www.haleyl.com/2017/07/04/php/php-timer/</id>
    <published>2017-07-04T07:29:42.000Z</published>
    <updated>2021-03-31T04:01:58.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Carbon 是继承自 PHP DateTime 类 的子类，但比后者提供了更加丰富、更加语义化的 API。其中一个比较实用的 API 就是 diffForHumans 方法，几乎每个用 Laravel 构建的项目中都有用到它。</p></blockquote><p>比如，一个博客系统里的文章发布时间，显示格式可能就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**距离现在时间**     **显示格式**</span><br><span class="line">&lt; 1小时           xx分钟前</span><br><span class="line">1小时 - 24小时     xx小时前 </span><br><span class="line">1天 - 15天         xx天前</span><br><span class="line">&gt; 15天            直接显示日期</span><br></pre></td></tr></table></figure><p>** 第一步：<br>本地化 Carbon。在 AppServiceProvider 的 boot 方法中添加 Carbon::setLocale(‘zh’)。<br><img src="https://img-blog.csdn.net/20180503082345106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Carbon::setLocale(&#39;zh&#39;);</span><br></pre></td></tr></table></figure><p>** 第二步：<br>在 Model 中设定要人性化显示的字段。以 Article Model 的 created_at 字段为例。<br><img src="https://img-blog.csdn.net/20180503082441347?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public function getCreatedAtAttribute($value)&#123;</span><br><span class="line">   return Carbon::createFromFormat(&#39;Y-m-d H:i:s&#39;, $value)-&gt;diffForHumans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就可以直接使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$article-&gt;created_at;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Carbon 是继承自 PHP DateTime 类 的子类，但比后者提供了更加丰富、更加语义化的 API。其中一个比较实用的 API 就是 diffForHumans 方法，几乎每个用 Laravel 构建的项目中都有用到它。&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="php" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/php/"/>
    
    
    <category term="php" scheme="http://www.haleyl.com/tags/php/"/>
    
    <category term="laravel" scheme="http://www.haleyl.com/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel new 项目缺少Vendor（composer忽略php7版本）</title>
    <link href="http://www.haleyl.com/2017/06/04/php/php-vendor/"/>
    <id>http://www.haleyl.com/2017/06/04/php/php-vendor/</id>
    <published>2017-06-04T07:23:11.000Z</published>
    <updated>2021-03-31T04:01:58.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><blockquote><p>Your requirements could not be resolved to an installable set of packages.</p></blockquote><p><img src="https://img-blog.csdn.net/20180428160446447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDEzMDA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>php不匹配composer.json要求的版本</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>composer install –ignore-platform-reqs<br>composer update –ignore-platform-reqs<br>composer create-project –prefer-dist laravel/laravel blog “5.5.*”</p></blockquote><h2 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h2><p>未满足一下条件</p><blockquote></blockquote><ul><li>PHP &gt;= 7.0.0</li><li>PHP OpenSSL 扩展 </li><li>PHP PDO 扩展 </li><li>PHP Mbstring 扩展 </li><li>PHP Tokenizer扩展 </li><li>PHP XML 扩展</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;错误&quot;&gt;&lt;a href=&quot;#错误&quot; class=&quot;headerlink&quot; title=&quot;错误&quot;&gt;&lt;/a&gt;错误&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Your requirements could not be resolved to an installable</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="php" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/php/"/>
    
    
    <category term="php" scheme="http://www.haleyl.com/tags/php/"/>
    
    <category term="laravel" scheme="http://www.haleyl.com/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>数据库优化之索引优化</title>
    <link href="http://www.haleyl.com/2017/05/15/mysql/mysql-index/"/>
    <id>http://www.haleyl.com/2017/05/15/mysql/mysql-index/</id>
    <published>2017-05-15T10:24:35.000Z</published>
    <updated>2021-03-31T09:08:59.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL支持的索引类型"><a href="#MySQL支持的索引类型" class="headerlink" title="MySQL支持的索引类型"></a>MySQL支持的索引类型</h2><ul><li>B-tree索引</li><li>Hash索引</li></ul><hr><h2 id="B-tree索引"><a href="#B-tree索引" class="headerlink" title="B-tree索引"></a>B-tree索引</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>加快数据的查询速度</li><li>更适合进行范围查找<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4></li><li>B+树的结构存储数据<br>####适应范围</li><li>全值匹配的查询</li><li>匹配最左前缀的查询</li><li>匹配列前缀查询</li><li>匹配范围值的查询</li><li>精确匹配左前列并范围匹配另外一列</li><li>只访问索引的查询<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4></li><li>如果不是按照索引最左列开始查找，则无法使用索引</li><li>使用索引时不能跳过索引中的列</li><li>Not in 和&lt;&gt;操作无法使用索引</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引</li></ul><hr><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>Hash索引时基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列，才能够使用Hash索引。</li><li>对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4></li><li>key-vlaue<h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4></li><li>二次读取</li><li>无法用于排序</li><li>不支持部分索引查找也不支持范围查找</li><li>Hash码的计算可能存在Hash冲突</li></ul><hr><h2 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h2><ul><li>大大减少存储引擎需要扫描的数据量</li><li>帮助我们进行排序避免使用临时表</li><li>把随机I/O变为顺序I/O</li></ul><hr><h2 id="索引是不是越多越好"><a href="#索引是不是越多越好" class="headerlink" title="索引是不是越多越好"></a>索引是不是越多越好</h2><ul><li>索引会增加写操作的成本</li><li>太多的索引会增加查询优化器的选择时间</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL支持的索引类型&quot;&gt;&lt;a href=&quot;#MySQL支持的索引类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL支持的索引类型&quot;&gt;&lt;/a&gt;MySQL支持的索引类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;B-tree索引&lt;/li&gt;
&lt;li&gt;Hash索引</summary>
      
    
    
    
    <category term="后端" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="mysql" scheme="http://www.haleyl.com/categories/%E5%90%8E%E7%AB%AF/mysql/"/>
    
    
    <category term="mysql" scheme="http://www.haleyl.com/tags/mysql/"/>
    
    <category term="优化" scheme="http://www.haleyl.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
